package com.edusoftwerks.gwtboot.cli;

import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Properties;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Stream;

class Utils {

  static String extractPackageFromPom(Path pomPath) throws IOException {
    String content = Files.readString(pomPath);

    // Try to extract from <start-class> tag
    Pattern pattern = Pattern.compile(
      "<start-class>([a-zA-Z0-9_.]+)\\.Application</start-class>"
    );
    Matcher matcher = pattern.matcher(content);

    if (matcher.find()) {
      return matcher.group(1);
    }

    return null;
  }

  /**
   * Reads the version number from the Maven pom.properties file packaged in the JAR.
   * This file is automatically generated by Maven during the package phase.
   *
   * @return the version string, or "unknown" if it cannot be determined
   */
  static String getVersion() {
    try (
      InputStream in = Utils.class.getResourceAsStream(
          "/META-INF/maven/com.edusoftwerks/gwt-boot-cli/pom.properties"
        )
    ) {
      if (in != null) {
        Properties props = new Properties();
        props.load(in);
        return props.getProperty("version", "unknown");
      }
    } catch (IOException e) {
      // Fall through to return unknown
    }
    return "unknown";
  }

  /**
   * Reads the version from a pom.xml file directly.
   * This is useful when running from source rather than from a packaged JAR.
   *
   * @param pomPath the path to the pom.xml file
   * @return the version string, or null if it cannot be determined
   * @throws IOException if an error occurs reading the file
   */
  static String extractVersionFromPom(Path pomPath) throws IOException {
    String content = Files.readString(pomPath);

    // Try to extract from <revision> property first (used in this project)
    Pattern revisionPattern = Pattern.compile("<revision>([^<]+)</revision>");
    Matcher revisionMatcher = revisionPattern.matcher(content);
    if (revisionMatcher.find()) {
      return revisionMatcher.group(1);
    }

    // Try to extract from <version> tag
    Pattern versionPattern = Pattern.compile("<version>([^<$]+)</version>");
    Matcher versionMatcher = versionPattern.matcher(content);
    if (versionMatcher.find()) {
      String version = versionMatcher.group(1);
      // If it's a property reference like ${revision}, try to resolve it
      if (!version.startsWith("${")) {
        return version;
      }
    }

    return null;
  }

  static String extractGwtVersionFromPom(Path pomPath) throws IOException {
    String content = Files.readString(pomPath);

    // Look for gwt.version property
    Pattern pattern = Pattern.compile("<gwt\\.version>([^<]+)</gwt\\.version>");
    Matcher matcher = pattern.matcher(content);

    if (matcher.find()) {
      return matcher.group(1);
    }

    return null;
  }

  static int executeMavenCommand(String... goals)
    throws IOException, InterruptedException {
    List<String> command = new ArrayList<>();
    command.add("mvn");
    Collections.addAll(command, goals);
    return ProcessExecutor.executeCommand(command);
  }

  static List<String> findGwtModules() throws IOException {
    List<String> modules = new ArrayList<>();
    Path srcMainJava = Paths.get("src/main/java");

    if (!Files.exists(srcMainJava)) {
      return modules;
    }

    try (Stream<Path> paths = Files.walk(srcMainJava)) {
      paths
        .filter(Files::isRegularFile)
        .filter(p -> p.toString().endsWith(".gwt.xml"))
        .forEach(
          path -> {
            // Convert file path to module name
            // e.g., src/main/java/com/example/App.gwt.xml -> com.example.App
            String relativePath = srcMainJava.relativize(path).toString();
            String moduleName = relativePath
              .replace('/', '.')
              .replace('\\', '.')
              .replace(".gwt.xml", "");
            modules.add(moduleName);
          }
        );
    }

    return modules;
  }

  static String buildClasspath(String gwtVersion)
    throws IOException, InterruptedException {
    String pathSeparator = System.getProperty("path.separator");
    List<String> classpathEntries = new ArrayList<>();

    // Use Maven to build the complete classpath including all transitive dependencies
    Console.info("Building classpath from Maven dependencies...");
    String mavenClasspath = getMavenClasspath();

    if (mavenClasspath != null && !mavenClasspath.isEmpty()) {
      // Add Maven-resolved dependencies
      String[] mavenJars = mavenClasspath.split(pathSeparator);
      for (String jar : mavenJars) {
        if (!jar.trim().isEmpty()) {
          classpathEntries.add(jar.trim());
        }
      }
    } else {
      Console.error("Failed to build classpath from Maven");
      return null;
    }

    // Add project's source and compiled classes
    classpathEntries.add("src/main/java");
    classpathEntries.add("target/classes");

    return String.join(pathSeparator, classpathEntries);
  }

  static String getMavenClasspath() throws IOException, InterruptedException {
    // Ensure target directory exists
    Files.createDirectories(Paths.get("target"));

    List<String> command = new ArrayList<>();
    command.add("mvn");
    command.add("dependency:build-classpath");
    command.add("-DincludeScope=test"); // test scope includes compile, runtime, and provided
    command.add("-Dmdep.outputFile=target/classpath.txt");

    ProcessBuilder pb = new ProcessBuilder(command);
    pb.inheritIO();
    Process process = pb.start();
    int exitCode = process.waitFor();

    if (exitCode != 0) {
      Console.warning(
        "Maven dependency:build-classpath failed with exit code " + exitCode
      );
      return null;
    }

    // Read the classpath from the output file
    Path classpathFile = Paths.get("target/classpath.txt");
    if (Files.exists(classpathFile)) {
      String classpath = Files.readString(classpathFile).trim();
      // Don't delete - keep for debugging
      return classpath;
    }

    Console.warning("Classpath file not found at target/classpath.txt");
    return null;
  }

  static String capitalize(String str) {
    if (str == null || str.isEmpty()) {
      return str;
    }
    return str.substring(0, 1).toUpperCase() + str.substring(1);
  }

  static String toSnakeCase(String str) {
    if (str == null || str.isEmpty()) {
      return str;
    }
    return str.replaceAll("([a-z])([A-Z])", "$1_$2").toLowerCase();
  }
}
